// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Belt_List from "rescript/lib/es6/belt_List.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as Caml_exceptions from "rescript/lib/es6/caml_exceptions.js";

function make(routeNamePath, loc) {
  return {
          routeNamePath: routeNamePath,
          loc: loc
        };
}

function getRouteName(t) {
  return Belt_Option.getWithDefault(Caml_option.undefined_to_opt(Belt_List.toArray(t.routeNamePath).pop()), "");
}

function getFullRouteName(t) {
  return Belt_List.toArray(t.routeNamePath).join("__");
}

function getFullRouteAccessPath(t) {
  return Belt_List.toArray(t.routeNamePath).join(".") + ".Route";
}

function getRouteRendererFileName(t) {
  return getFullRouteName(t) + "_route_renderer.res";
}

function toGeneratedRouteModuleName(t) {
  return "Route__" + getFullRouteName(t) + "_route";
}

function getLoc(t) {
  return t.loc;
}

var RouteName = {
  make: make,
  getRouteName: getRouteName,
  getFullRouteName: getFullRouteName,
  getFullRouteAccessPath: getFullRouteAccessPath,
  getRouteRendererFileName: getRouteRendererFileName,
  toGeneratedRouteModuleName: toGeneratedRouteModuleName,
  getLoc: getLoc
};

var Unmapped_url_part = /* @__PURE__ */Caml_exceptions.create("RescriptRelayRouterCli__Types.Unmapped_url_part");

function transformUrlPart(urlPart, pathParams) {
  if (!urlPart.startsWith(":")) {
    if (urlPart === "/") {
      return ;
    } else {
      return urlPart;
    }
  }
  var paramName = urlPart.slice(1);
  if (pathParams.includes(paramName)) {
    return "${" + paramName + "->Js.Global.encodeURIComponent}";
  }
  throw {
        RE_EXN_ID: Unmapped_url_part,
        Error: new Error()
      };
}

function make$1(path, currentRoutePath) {
  var cleanPath = Belt_Option.getWithDefault(Belt_Array.get(path.split("?"), 0), "");
  return {
          pathSegment: cleanPath,
          currentRoutePath: Belt_List.keep(Belt_List.concat(Belt_List.reverse(Belt_List.fromArray(cleanPath.split("/"))), currentRoutePath.currentRoutePath), (function (urlPart) {
                  return urlPart !== "";
                }))
        };
}

function getPathSegment(t) {
  return t.pathSegment;
}

function getFullRoutePath(t) {
  return "/" + Belt_List.toArray(t.currentRoutePath).join("/");
}

function toTemplateString(t, pathParams) {
  return "/" + Belt_List.toArray(Belt_List.keepMap(Belt_List.reverse(t.currentRoutePath), (function (urlPart) {
                      return transformUrlPart(urlPart, pathParams);
                    }))).join("/");
}

function toPattern(t) {
  return "/" + Belt_List.toArray(Belt_List.keepMap(Belt_List.reverse(t.currentRoutePath), (function (part) {
                      if (part === "/") {
                        return ;
                      } else {
                        return part;
                      }
                    }))).join("/");
}

function empty(param) {
  return {
          pathSegment: "",
          currentRoutePath: /* [] */0
        };
}

function elgibleForRouteMaker(t) {
  return Belt_List.every(t.currentRoutePath, (function (urlSegment) {
                return /^[A-Za-z0-9:\/\-\._]*$/g.test(urlSegment);
              }));
}

var RoutePath = {
  make: make$1,
  getPathSegment: getPathSegment,
  getFullRoutePath: getFullRoutePath,
  toTemplateString: toTemplateString,
  toPattern: toPattern,
  empty: empty,
  elgibleForRouteMaker: elgibleForRouteMaker
};

export {
  RouteName ,
  Unmapped_url_part ,
  transformUrlPart ,
  RoutePath ,
  
}
/* No side effect */
