// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Fs from "fs";
import * as Lsp from "./lsp/Lsp.mjs";
import * as Path from "path";
import * as Curry from "rescript/lib/es6/curry.js";
import * as Js_exn from "rescript/lib/es6/js_exn.js";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import Chokidar from "chokidar";
import * as Belt_List from "rescript/lib/es6/belt_List.js";
import FastGlob from "fast-glob";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as ReactRouter from "react-router";
import * as Caml_js_exceptions from "rescript/lib/es6/caml_js_exceptions.js";
import * as RescriptRelayRouterCli__Types from "./RescriptRelayRouterCli__Types.mjs";
import * as RescriptRelayRouterCli__Utils from "./RescriptRelayRouterCli__Utils.mjs";
import * as RescriptRelayRouterCli__Codegen from "./RescriptRelayRouterCli__Codegen.mjs";
import * as RescriptRelayRouterCli__Bindings from "./RescriptRelayRouterCli__Bindings.mjs";
import * as RescriptRelayRouterCli__Diagnostics from "./RescriptRelayRouterCli__Diagnostics.mjs";

function scaffoldRouteRenderers(deleteRemoved, config) {
  var match = RescriptRelayRouterCli__Utils.readRouteStructure(config);
  var routeNamesDict = match[1];
  var existingRenderers = Curry._2(FastGlob.sync, ["**/*_route_renderer.res"], {
        cwd: RescriptRelayRouterCli__Utils.pathInRoutesFolder(config, undefined, undefined)
      });
  var routeNamesWithRenderers = {};
  Belt_Array.forEach(existingRenderers, (function (rendererFileName) {
          routeNamesWithRenderers[RescriptRelayRouterCli__Utils.fromRendererFileName(rendererFileName)] = true;
          
        }));
  if (deleteRemoved) {
    Belt_Array.forEach(existingRenderers, (function (rendererFileName) {
            var match = Js_dict.get(routeNamesDict, RescriptRelayRouterCli__Utils.fromRendererFileName(rendererFileName));
            if (match !== undefined) {
              return ;
            } else {
              console.log("Removing unused renderer \"" + rendererFileName + "\"");
              Fs.unlinkSync(RescriptRelayRouterCli__Utils.pathInRoutesFolder(config, rendererFileName, undefined));
              return ;
            }
          }));
  }
  return Belt_Array.forEach(Js_dict.entries(routeNamesDict), (function (param) {
                var routeName = param[0];
                var match = Js_dict.get(routeNamesWithRenderers, routeName);
                if (match !== undefined) {
                  return ;
                } else {
                  RescriptRelayRouterCli__Bindings.Fs.writeFileIfChanged(RescriptRelayRouterCli__Utils.pathInRoutesFolder(config, RescriptRelayRouterCli__Utils.toRendererFileName(routeName), undefined), "let renderer = Routes." + RescriptRelayRouterCli__Types.RouteName.getFullRouteAccessPath(param[1][0].name) + ".makeRenderer(\n  ~prepare=props => {\n    ()\n  },\n  ~render=props => {\n    React.null\n  },\n  (),\n)");
                  console.log("Added \"" + RescriptRelayRouterCli__Utils.toRendererFileName(routeName) + "\"");
                  return ;
                }
              }));
}

function generateRoutes(scaffoldAfter, deleteRemoved, config) {
  console.log("Generating routes...");
  var match = RescriptRelayRouterCli__Utils.readRouteStructure(config);
  var routeNamesDict = match[1];
  var routes = match[0];
  var routesFile = {
    contents: "//Â @generated\n// This file is autogenerated, do not edit manually\n"
  };
  Belt_Array.forEach(routes, (function (route) {
          return RescriptRelayRouterCli__Utils.add(routesFile, RescriptRelayRouterCli__Utils.printNestedRouteModules(route, 0));
        }));
  RescriptRelayRouterCli__Bindings.Fs.writeFileIfChanged(RescriptRelayRouterCli__Utils.pathInGeneratedFolder(config, "Routes.res", undefined), routesFile.contents);
  var currentFilesInOutputTarget = Curry._2(FastGlob.sync, ["Route__*_route.res"], {
        cwd: RescriptRelayRouterCli__Utils.pathInGeneratedFolder(config, undefined, undefined)
      });
  Belt_Array.forEach(currentFilesInOutputTarget, (function (fileName) {
          var match = fileName.endsWith("_route.res");
          var match$1 = fileName.startsWith("Route__");
          var shouldDelete;
          if (match && match$1) {
            var routeName = fileName.slice("Route__".length).replace("_route.res", "");
            shouldDelete = Belt_Option.isNone(Js_dict.get(routeNamesDict, routeName));
          } else {
            shouldDelete = false;
          }
          if (shouldDelete) {
            Fs.unlinkSync(RescriptRelayRouterCli__Utils.pathInGeneratedFolder(config, fileName, undefined));
            return ;
          }
          
        }));
  Belt_Array.forEach(Js_dict.values(routeNamesDict), (function (param) {
          var route = param[0];
          var assetsContent = "// @generated\n// This file is autogenerated from `" + route.sourceFile + "`, do not edit manually.\n" + RescriptRelayRouterCli__Codegen.getRouteMakerIfElgible(route) + "\n\n" + RescriptRelayRouterCli__Codegen.getActiveRouteAssets(route) + "\n\n" + RescriptRelayRouterCli__Codegen.getPrepareAssets(route) + "\n\n" + RescriptRelayRouterCli__Codegen.getQueryParamAssets(route);
          return RescriptRelayRouterCli__Bindings.Fs.writeFileIfChanged(RescriptRelayRouterCli__Utils.pathInGeneratedFolder(config, RescriptRelayRouterCli__Types.RouteName.toGeneratedRouteModuleName(route.name) + ".res", undefined), assetsContent);
        }));
  var routeNamesEntries = Js_dict.entries(routeNamesDict);
  var fileContents = "\n@val external suspend: Js.Promise.t<'any> => unit = \"throw\"\n\nexception Route_loading_failed(string)\n\n" + Belt_Array.map(routeNamesEntries, (function (param) {
            var routeName = param[0];
            return "\nmodule type T__" + routeName + " = module type of " + routeName + "_route_renderer\n@val external import__" + routeName + ": (@as(json`\"@rescriptModule/" + routeName + "_route_renderer\"`) _, unit) => Js.Promise.t<module(T__" + routeName + ")> = \"import\"";
          })).join("\n") + "\n\ntype loadedRouteRenderer<'routeRendererModule> = NotInitiated | Pending(Js.Promise.t<'routeRendererModule>) | Loaded('routeRendererModule)\n\ntype loadedRouteRendererMap = {\n" + Belt_Array.map(routeNamesEntries, (function (param) {
            var routeName = param[0];
            return "  mutable renderer_" + routeName + ": loadedRouteRenderer<module(T__" + routeName + ")>,";
          })).join("\n") + "\n}\n\nlet loadedRouteRenderers: loadedRouteRendererMap = {\n" + Belt_Array.map(routeNamesEntries, (function (param) {
            return "  renderer_" + param[0] + ": NotInitiated,";
          })).join("\n") + "\n}\n\ntype preparedContainer = {\n  dispose: (. unit) => unit,\n  render: RelayRouterTypes.renderRouteFn,\n  mutable timeout: option<Js.Global.timeoutId>\n}\n\nlet make = (~prepareDisposeTimeout=5 * 60 * 1000, ()): array<RelayRouterTypes.route> => {\n  let preparedMap: Belt.HashMap.String.t<preparedContainer> = Belt.HashMap.String.make(~hintSize=" + String(routeNamesEntries.length) + ")\n\n  let getPrepared = (~routeKey) => \n    preparedMap->Belt.HashMap.String.get(routeKey)\n\n  let disposeOfPrepared = (~routeKey) => {\n    switch getPrepared(~routeKey) {\n      | None => ()\n      | Some({dispose}) => dispose(.)\n    }\n  }\n\n  let clearTimeout = (~routeKey) => {\n    switch getPrepared(~routeKey) {\n      | Some({timeout: Some(timeoutId)}) => Js.Global.clearTimeout(timeoutId)\n      | _ => ()\n    }\n  }\n\n  let expirePrepared = (~routeKey) => {\n    disposeOfPrepared(~routeKey)\n    clearTimeout(~routeKey)\n    preparedMap->Belt.HashMap.String.remove(routeKey)\n  }\n\n  let setTimeout = (~routeKey) => {\n    clearTimeout(~routeKey)\n    switch getPrepared(~routeKey) {\n      | Some(r) => \n        r.timeout = Some(Js.Global.setTimeout(() => {\n          disposeOfPrepared(~routeKey)\n          expirePrepared(~routeKey)\n        }, prepareDisposeTimeout))\n      | None => ()\n    }\n  }\n\n  let addPrepared = (~routeKey, ~dispose, ~render) => {\n    preparedMap->Belt.HashMap.String.set(routeKey, {\n      dispose,\n      render,\n      timeout: None\n    })\n\n\n    setTimeout(~routeKey)\n  }\n\n  [\n    " + routes.map(function (route) {
          return RescriptRelayRouterCli__Codegen.getRouteDefinition(route, 1);
        }).join(",\n") + "\n  ]\n}";
  RescriptRelayRouterCli__Bindings.Fs.writeFileIfChanged(RescriptRelayRouterCli__Utils.pathInGeneratedFolder(config, "RouteDeclarations.res", undefined), fileContents);
  RescriptRelayRouterCli__Bindings.Fs.writeFileIfChanged(RescriptRelayRouterCli__Utils.pathInGeneratedFolder(config, "RouteDeclarations.resi", undefined), "let make: (~prepareDisposeTimeout: int=?, unit) => array<RelayRouterTypes.route>");
  if (scaffoldAfter) {
    scaffoldRouteRenderers(deleteRemoved, config);
  }
  console.log("Done!");
  
}

function printRouteInfo(url, config) {
  var match = RescriptRelayRouterCli__Utils.readRouteStructure(config);
  var urlObj = new URL(url.startsWith("http") ? url : "http://localhost" + url);
  var matched = Belt_Option.getWithDefault(Caml_option.nullable_to_opt(ReactRouter.matchRoutes(Belt_Array.map(match[0], RescriptRelayRouterCli__Utils.rawRouteToMatchable), {
                pathname: urlObj.pathname,
                search: Belt_Option.getWithDefault(urlObj.search, ""),
                hash: urlObj.hash,
                state: urlObj.state
              })), []);
  var matchCount = matched.length;
  if (matchCount !== 0) {
    var str = {
      contents: "URL matched " + matchCount.toString() + " route(s).\n\n===== Matched structure:\n"
    };
    var indentation = {
      contents: 0
    };
    var strEnd = {
      contents: ""
    };
    Belt_Array.forEachWithIndex(matched, (function (index, matchedRoute) {
            var propsForRoute = Belt_Array.keep(Js_dict.entries(matchedRoute.params), (function (param) {
                    return matchedRoute.route.params.includes(param[0]);
                  }));
            str.contents = str.contents + "\n" + ("  ".repeat(indentation.contents) + "// In \"" + matchedRoute.route.sourceFile + "\"\n") + "  ".repeat(indentation.contents) + ("<" + matchedRoute.route.name + Belt_Array.map(propsForRoute, (function (param) {
                        return " " + param[0] + "=\"" + param[1] + "\"";
                      })).join("") + ">");
            if ((index + 1 | 0) !== matchCount) {
              strEnd.contents = strEnd.contents + "\n" + "  ".repeat(indentation.contents) + ("</" + matchedRoute.route.name + ">");
            }
            indentation.contents = indentation.contents + 1 | 0;
            
          }));
    console.log(str.contents + "\n" + strEnd.contents.split("\n").reverse().join("\n"));
    return ;
  }
  console.log("URL did not match any routes.");
  
}

function init(param) {
  if (RescriptRelayRouterCli__Utils.Config.exists(undefined)) {
    console.log("[init] Config exists, moving on...");
  } else {
    console.log("[init] Config does not exist, creating default one...");
    var path = Path.resolve(process.cwd(), "./rescriptRelayRouter.config.cjs");
    Fs.writeFileSync(path, "module.exports = " + JSON.stringify({
              routesFolderPath: "./src/routes"
            }, null, 2));
    console.log("[init] Config created at: " + path);
  }
  try {
    var config = RescriptRelayRouterCli__Utils.Config.load(undefined);
    var routesJsonPath = RescriptRelayRouterCli__Utils.pathInRoutesFolder(config, "routes.json", undefined);
    if (!Fs.existsSync(routesJsonPath)) {
      console.log("[init] `routes.json` does not exist, creating...");
      Fs.writeFileSync(routesJsonPath, JSON.stringify([
                {
                  path: "/",
                  name: "Root",
                  children: []
                },
                {
                  path: "*",
                  name: "FourOhFour"
                }
              ], null, 2));
      console.log("[init] Basic `routes.json` added at: " + routesJsonPath);
    }
    
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === RescriptRelayRouterCli__Utils.Invalid_config) {
      console.log("[init] Config existed, but was misconfigured. Re-configure it and rerun this command.");
      process.exit(0);
    } else {
      throw exn;
    }
  }
  console.log("[init] Done! You can now run the `generate -scaffold-renderers` command.");
  
}

function runCli(args) {
  var match = Belt_List.fromArray(args);
  if (match) {
    switch (match.hd) {
      case "-h" :
      case "-help" :
          console.log("Usage:\n  init                                                      | Inits the config for the router.\n\n  lsp                                                       | Starts a language server for the router.\n    [-stdio]                                                |   [-stdio] will start the LS in stdio mode. Default is Node RPC mode.\n\n  generate\n    [-scaffold-renderers] [-delete-removed] [-w, --watch]   | Generates all routing code. Run this after making changes.\n                                                            |   [-scaffold-renderers] will also run the command to scaffold \n                                                            |   route renderers.\n                                                            |   [-w, --watch] runs this command in watch mode.\n\n  scaffold-route-renderers\n    [-delete-removed]                                       | Will automatically add route renderer files for all routes that \n                                                            | do not have them. \n                                                            |   [-delete-removed] will remove any route renderer that does not \n                                                            |   have a route defined anymore.\n\n  find-route <url>                                          | Shows what routes/components will render for a specific route.\n                                                            | Example: find-route /todos/123");
          return /* Done */0;
      case "find-route" :
          var match$1 = match.tl;
          if (match$1) {
            if (match$1.tl) {
              console.log("Unknown command. Use -help or -h to see all available commands.");
              return /* Done */0;
            }
            var config = RescriptRelayRouterCli__Utils.Config.load(undefined);
            printRouteInfo(match$1.hd, config);
            return /* Done */0;
          }
          console.log("Unknown command. Use -help or -h to see all available commands.");
          return /* Done */0;
      case "generate" :
          var options = match.tl;
          var scaffoldAfterGenerating = Belt_List.has(options, "-scaffold-renderers", (function (prim0, prim1) {
                  return prim0 === prim1;
                }));
          var deleteRemoved = Belt_List.has(options, "-delete-removed", (function (prim0, prim1) {
                  return prim0 === prim1;
                }));
          var shouldWatch = Belt_List.has(options, "-w", (function (prim0, prim1) {
                  return prim0 === prim1;
                })) || Belt_List.has(options, "--watch", (function (prim0, prim1) {
                  return prim0 === prim1;
                }));
          var config$1 = RescriptRelayRouterCli__Utils.Config.load(undefined);
          RescriptRelayRouterCli__Utils.ensureRouteStructure(config$1.routesFolderPath);
          var generateRoutesSafe = function (param) {
            try {
              return generateRoutes(scaffoldAfterGenerating, deleteRemoved, config$1);
            }
            catch (raw_e){
              var e = Caml_js_exceptions.internalToOCamlException(raw_e);
              if (e.RE_EXN_ID === Js_exn.$$Error) {
                console.log(e._1.message);
                return ;
              } else if (e.RE_EXN_ID === RescriptRelayRouterCli__Utils.Decode_error) {
                return RescriptRelayRouterCli__Diagnostics.printDiagnostics(e._1, config$1);
              } else {
                console.log("Something went wrong generating your routes. Please check the validity of `routes.json`.");
                return ;
              }
            }
          };
          generateRoutesSafe(undefined);
          if (!shouldWatch) {
            return /* Done */0;
          }
          console.log("Watching routes...");
          var theWatcher = Chokidar.watch(RescriptRelayRouterCli__Utils.pathInRoutesFolder(config$1, "*.json", undefined)).on("change", (function (param) {
                    return generateRoutesSafe(undefined);
                  })).on("unlink", (function (param) {
                  return generateRoutesSafe(undefined);
                }));
          return /* Watcher */{
                  watcher: theWatcher
                };
      case "init" :
          if (match.tl) {
            console.log("Unknown command. Use -help or -h to see all available commands.");
            return /* Done */0;
          } else {
            init(undefined);
            return /* Done */0;
          }
      case "lsp" :
          var config$2 = RescriptRelayRouterCli__Utils.Config.load(undefined);
          var mode = Belt_List.has(match.tl, "-stdio", (function (prim0, prim1) {
                  return prim0 === prim1;
                })) ? /* Stdio */1 : /* NodeRpc */0;
          var watcher = Lsp.start(mode, config$2);
          return /* Watcher */{
                  watcher: watcher
                };
      case "scaffold-route-renderers" :
          var deleteRemoved$1 = Belt_List.has(match.tl, "-delete-removed", (function (prim0, prim1) {
                  return prim0 === prim1;
                }));
          var config$3 = RescriptRelayRouterCli__Utils.Config.load(undefined);
          RescriptRelayRouterCli__Utils.ensureRouteStructure(config$3.routesFolderPath);
          console.log("Scaffolding route renderers...");
          try {
            scaffoldRouteRenderers(deleteRemoved$1, config$3);
            console.log("Done!");
          }
          catch (raw_routeStructure){
            var routeStructure = Caml_js_exceptions.internalToOCamlException(raw_routeStructure);
            if (routeStructure.RE_EXN_ID === RescriptRelayRouterCli__Utils.Decode_error) {
              RescriptRelayRouterCli__Diagnostics.printDiagnostics(routeStructure._1, config$3);
            } else {
              throw routeStructure;
            }
          }
          return /* Done */0;
      default:
        console.log("Unknown command. Use -help or -h to see all available commands.");
        return /* Done */0;
    }
  } else {
    console.log("Unknown command. Use -help or -h to see all available commands.");
    return /* Done */0;
  }
}

var Codegen;

var Utils;

var $$History;

var Types;

var Diagnostics;

export {
  Codegen ,
  Utils ,
  $$History ,
  Types ,
  Diagnostics ,
  scaffoldRouteRenderers ,
  generateRoutes ,
  printRouteInfo ,
  init ,
  runCli ,
  
}
/* fs Not a pure module */
