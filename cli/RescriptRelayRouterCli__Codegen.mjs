// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as RescriptRelayRouterCli__Types from "./RescriptRelayRouterCli__Types.mjs";
import * as RescriptRelayRouterCli__Utils from "./RescriptRelayRouterCli__Utils.mjs";

function wrapInOpt(str) {
  return "option<" + str + ">";
}

var protectedNames = [
  "environment",
  "pathParams",
  "queryParams",
  "location"
];

function makeSafeParamName(paramName, params) {
  if (paramName.TAG === /* Param */0) {
    var paramName$1 = paramName._0;
    if (protectedNames.includes(paramName$1)) {
      return {
              TAG: /* CollisionPrevented */1,
              realKey: paramName$1,
              collisionProtectedKey: "param_" + paramName$1
            };
    } else {
      return {
              TAG: /* Actual */0,
              _0: paramName$1
            };
    }
  }
  var paramName$2 = paramName._0;
  if (params.includes(paramName$2) || protectedNames.includes(paramName$2)) {
    return {
            TAG: /* CollisionPrevented */1,
            realKey: paramName$2,
            collisionProtectedKey: "queryParam_" + paramName$2
          };
  } else {
    return {
            TAG: /* Actual */0,
            _0: paramName$2
          };
  }
}

function getSafeKey(key) {
  if (key.TAG === /* Actual */0) {
    return key._0;
  } else {
    return key.collisionProtectedKey;
  }
}

function getOriginalKey(key) {
  if (key.TAG === /* Actual */0) {
    return key._0;
  } else {
    return key.realKey;
  }
}

var SafeParam = {
  protectedNames: protectedNames,
  makeSafeParamName: makeSafeParamName,
  getSafeKey: getSafeKey,
  getOriginalKey: getOriginalKey
};

function getRouteMaker(route) {
  var labeledArguments = Belt_Array.map(route.params, (function (paramName) {
          return [
                  paramName,
                  "string"
                ];
        }));
  var queryParamSerializers = [];
  Belt_Array.forEach(Js_dict.entries(route.queryParams), (function (param) {
          var paramType = param[1];
          var key = makeSafeParamName({
                TAG: /* QueryParam */1,
                _0: param[0]
              }, route.params);
          labeledArguments.push([
                getSafeKey(key),
                "option<" + RescriptRelayRouterCli__Utils.QueryParams.toTypeStr(paramType) + ">=?"
              ]);
          queryParamSerializers.push([
                key,
                RescriptRelayRouterCli__Utils.QueryParams.toSerializer(paramType, getSafeKey(key))
              ]);
          
        }));
  var hasQueryParams = queryParamSerializers.length > 0;
  var str = {
    contents: "@live\nlet makeLink = ("
  };
  var numLabeledArguments = labeledArguments.length;
  Belt_Array.forEachWithIndex(labeledArguments, (function (index, param) {
          str.contents = str.contents + ("~" + param[0] + ": " + param[1]);
          if ((index + 1 | 0) < numLabeledArguments) {
            str.contents = str.contents + ", ";
            return ;
          }
          
        }));
  if (hasQueryParams) {
    str.contents = str.contents + ", ()";
  }
  str.contents = str.contents + ") => {\n";
  var urlTemplateString = RescriptRelayRouterCli__Types.RoutePath.toTemplateString(route.path, route.params);
  if (hasQueryParams) {
    str.contents = str.contents + "  open RelayRouter__Bindings\n  let queryParams = QueryParams.make()";
    Belt_Array.forEach(queryParamSerializers, (function (param) {
            var key = param[0];
            str.contents = str.contents + ("\n  switch " + getSafeKey(key) + " {\n    | None => ()\n    | Some(" + getSafeKey(key) + ") => queryParams->QueryParams.setParam(~key=\"" + getOriginalKey(key) + "\", ~value=" + param[1] + ")\n  }\n");
            
          }));
  }
  str.contents = str.contents + "  `" + urlTemplateString;
  if (hasQueryParams) {
    str.contents = str.contents + "${queryParams->QueryParams.toString}";
  }
  str.contents = str.contents + "`";
  str.contents = str.contents + "\n}";
  return str.contents;
}

function getRouteMakerIfElgible(route) {
  if (RescriptRelayRouterCli__Types.RoutePath.elgibleForRouteMaker(route.path)) {
    return getRouteMaker(route);
  } else {
    return "\n// Route maker omitted because URL path includes segments that cannot be constructed (usually '*', or a regexp).\n";
  }
}

function getQueryParamAssets(route) {
  var queryParamEntries = Js_dict.entries(route.queryParams);
  if (queryParamEntries.length <= 0) {
    return "";
  }
  var str = {
    contents: "type queryParams = {"
  };
  Belt_Array.forEach(queryParamEntries, (function (param) {
          str.contents = str.contents + ("\n  " + param[0] + ": option<" + RescriptRelayRouterCli__Utils.QueryParams.toTypeStr(param[1]) + ">,");
          
        }));
  str.contents = str.contents + "\n}\n\n";
  str.contents = str.contents + ("@live\nlet parseQueryParams = (search: string): queryParams => {\n  open RelayRouter__Bindings\n  let queryParams = QueryParams.parse(search)\n  {" + Belt_Array.map(queryParamEntries, (function (param) {
              var key = param[0];
              return "\n    " + key + ": queryParams->QueryParams." + RescriptRelayRouterCli__Utils.queryParamToQueryParamDecoder(param[1], key);
            })).join("") + "\n  }\n}\n\n@live\nlet makeQueryParams = (" + Belt_Array.map(queryParamEntries, (function (param) {
              return "\n  ~" + param[0] + ": option<" + RescriptRelayRouterCli__Utils.QueryParams.toTypeStr(param[1]) + ">=?, ";
            })).join("") + "\n  ()\n) => {" + Belt_Array.map(queryParamEntries, (function (param) {
              var key = param[0];
              return "\n  " + key + ": " + key + ",";
            })).join("") + "\n}\n\n@live\nlet setQueryParams = (\n  newParams: queryParams,\n  ~currentSearch: string, \n  ~navigationMode_=RelayRouterTypes.Push,\n  ~removeNotControlledParams=true,\n  ~history: RelayRouter__Bindings.History.t,\n  ()\n) => {\n  open RelayRouter__Bindings\n\n  let queryParams = if removeNotControlledParams {\n    QueryParams.make()\n  } else {\n    QueryParams.parse(currentSearch)\n  }\n\n  " + Belt_Array.map(queryParamEntries, (function (param) {
              var key = param[0];
              return "\n  queryParams->QueryParams.setParamOpt(~key=\"" + key + "\", ~value=newParams." + key + "->Belt.Option.map(" + key + " => " + RescriptRelayRouterCli__Utils.QueryParams.toSerializer(param[1], key) + "))";
            })).join("") + "\n  \n  queryParams->RelayRouter__Internal.setQueryParams(navigationMode_, history)\n}\n\n@live\ntype useQueryParamsReturn = {\n  queryParams: queryParams,\n  setParams: (\n    ~setter: queryParams => queryParams,\n    ~onAfterParamsSet: queryParams => unit=?,\n    ~navigationMode_: RelayRouterTypes.setQueryParamsMode=?,\n    ~removeNotControlledParams: bool=?,\n    unit\n  ) => unit\n}\n\n@live\nlet useQueryParams = (): useQueryParamsReturn => {\n  let {history} = RelayRouter.useRouterContext()\n  let {search} = RelayRouterUtils.useLocation()\n  let currentQueryParams = React.useMemo1(() => {\n    search->parseQueryParams\n  }, [search])\n\n  let searchRef = React.useRef(search)\n  let currentQueryParamsRef = React.useRef(currentQueryParams)\n\n  searchRef.current = search\n  currentQueryParamsRef.current = currentQueryParams\n\n  {\n    queryParams: currentQueryParams, \n    setParams: \n      React.useMemo0(\n        () => (\n          ~setter,\n          ~onAfterParamsSet=?,\n          ~navigationMode_=RelayRouterTypes.Push, \n          ~removeNotControlledParams=true,\n          ()\n        ) => {\n          let newParams = setter(currentQueryParamsRef.current)\n\n          switch onAfterParamsSet {\n            | None => ()\n            | Some(onAfterParamsSet) => onAfterParamsSet(newParams)\n          }\n\n          newParams\n            ->setQueryParams(\n              ~currentSearch=searchRef.current, \n              ~navigationMode_, \n              ~removeNotControlledParams, \n              ~history, \n              ()\n            )\n          },\n      )\n  }\n}");
  return str.contents;
}

function getPrepareAssets(route) {
  var hasQueryParams = Object.keys(route.queryParams).length > 0;
  var params = route.params;
  var str = {
    contents: "@live\ntype prepareProps = {\n"
  };
  var standardRecordFields = [
    [
      "environment",
      "RescriptRelay.Environment.t"
    ],
    [
      "location",
      "RelayRouter__Bindings.History.location"
    ]
  ];
  var pathParamsRecordFields = [];
  var queryParamsRecordFields = [];
  Belt_Array.forEach(params, (function (param) {
          pathParamsRecordFields.push([
                getSafeKey(makeSafeParamName({
                          TAG: /* Param */0,
                          _0: param
                        }, route.params)),
                "string"
              ]);
          
        }));
  Belt_Array.forEach(Js_dict.entries(route.queryParams), (function (param) {
          var safeParam = makeSafeParamName({
                TAG: /* QueryParam */1,
                _0: param[0]
              }, route.params);
          queryParamsRecordFields.push([
                getSafeKey(safeParam),
                wrapInOpt(RescriptRelayRouterCli__Utils.QueryParams.toTypeStr(param[1]))
              ]);
          
        }));
  var recordFields = standardRecordFields.concat(pathParamsRecordFields, queryParamsRecordFields);
  Belt_Array.forEach(recordFields, (function (param) {
          str.contents = str.contents + ("  " + param[0] + ": " + param[1] + ",\n");
          
        }));
  str.contents = str.contents + "}\n\n";
  str.contents = str.contents + ("let makeRouteKey = (\n  ~pathParams: Js.Dict.t<string>,\n  ~queryParams: RelayRouter__Bindings.QueryParams.t\n): string => {\n" + (
      pathParamsRecordFields.length === 0 ? "  ignore(pathParams)\n" : ""
    ) + (
      queryParamsRecordFields.length === 0 ? "  ignore(queryParams)\n" : ""
    ) + "\n  \"" + RescriptRelayRouterCli__Types.RouteName.getFullRouteName(route.name) + ":\"\n" + Belt_Array.map(pathParamsRecordFields, (function (param) {
              return "    ++ pathParams->Js.Dict.get(\"" + param[0] + "\")->Belt.Option.getWithDefault(\"\")";
            })).join("\n") + "\n" + Belt_Array.map(queryParamsRecordFields, (function (param) {
              return "    ++ queryParams->RelayRouter__Bindings.QueryParams.getParamByKey(\"" + param[0] + "\")->Belt.Option.getWithDefault(\"\")";
            })).join("\n") + "\n}\n\n");
  str.contents = str.contents + "@live\nlet makePrepareProps = (. \n  ~environment: RescriptRelay.Environment.t,\n  ~pathParams: Js.Dict.t<string>,\n  ~queryParams: RelayRouter__Bindings.QueryParams.t,\n  ~location: RelayRouter__Bindings.History.location,\n): prepareProps => {\n";
  var propsToIgnore = [
    params.length === 0 ? "pathParams" : undefined,
    hasQueryParams ? undefined : "queryParams"
  ];
  Belt_Array.forEach(Belt_Array.keepMap(propsToIgnore, (function (v) {
              return v;
            })), (function (propName) {
          str.contents = str.contents + ("  ignore(" + propName + ")\n");
          
        }));
  str.contents = str.contents + "  {\n    environment: environment,\n\n    location: location,\n";
  Belt_Array.forEach(params, (function (param) {
          str.contents = str.contents + ("    " + getSafeKey(makeSafeParamName({
                      TAG: /* Param */0,
                      _0: param
                    }, params)) + ": pathParams->Js.Dict.unsafeGet(\"" + param + "\"),\n");
          
        }));
  if (hasQueryParams) {
    Belt_Array.forEach(Js_dict.entries(route.queryParams), (function (param) {
            var safeParam = makeSafeParamName({
                  TAG: /* QueryParam */1,
                  _0: param[0]
                }, route.params);
            str.contents = str.contents + ("    " + getSafeKey(safeParam) + ": queryParams->RelayRouter__Bindings.QueryParams." + RescriptRelayRouterCli__Utils.queryParamToQueryParamDecoder(param[1], getOriginalKey(safeParam)));
            
          }));
  }
  str.contents = str.contents + "  }\n}\n\n";
  str.contents = str.contents + "@live\ntype renderProps<'prepared> = {\n  childRoutes: React.element,\n  prepared: 'prepared,\n";
  Belt_Array.forEach(recordFields, (function (param) {
          str.contents = str.contents + ("  " + param[0] + ": " + param[1] + ",\n");
          
        }));
  str.contents = str.contents + "}\n\n";
  str.contents = str.contents + "@live\ntype renderers<'prepared> = {\n  prepare: prepareProps => 'prepared,\n  prepareCode: option<(. prepareProps) => array<RelayRouterTypes.preloadAsset>>,\n  render: renderProps<'prepared> => React.element,\n}\n\n@obj\nexternal makeRenderer: (\n  ~prepare: prepareProps => 'prepared,\n  ~prepareCode: prepareProps => array<RelayRouterTypes.preloadAsset>=?,\n  ~render: renderProps<'prepared> => React.element,\n  unit\n) => renderers<'prepared> = \"\"";
  return str.contents;
}

function addIndentation(str, indentation) {
  return "  ".repeat(indentation) + str;
}

function getRouteDefinition(route, indentation) {
  var routeName = RescriptRelayRouterCli__Types.RouteName.getFullRouteName(route.name);
  var prepareParamsQueryParamsStr = Belt_Array.map(route.params, (function (param) {
            var safeParamName = getSafeKey(makeSafeParamName({
                      TAG: /* Param */0,
                      _0: param
                    }, route.params));
            return "                " + safeParamName + ": preparedProps." + safeParamName + ",";
          })).join("\n") + "\n" + Belt_Array.map(Js_dict.entries(route.queryParams), (function (param) {
            var safeParam = makeSafeParamName({
                  TAG: /* QueryParam */1,
                  _0: param[0]
                }, route.params);
            return "                " + getSafeKey(safeParam) + ": preparedProps." + getSafeKey(safeParam) + ",";
          })).join("\n");
  var str = "{\n  let loadRouteRenderer = () => {\n    let promise = import__" + routeName + "()\n    loadedRouteRenderers.renderer_" + routeName + " = Pending(promise)\n\n    promise->Js.Promise.then_(m => {\n      let module(M: T__" + routeName + ") = m\n      loadedRouteRenderers.renderer_" + routeName + " = Loaded(module(M))\n      Js.Promise.resolve()\n    }, _)\n  }\n\n  {\n    path: \"" + RescriptRelayRouterCli__Types.RoutePath.getPathSegment(route.path) + "\",\n    loadRouteRenderer,\n    preloadCode: (\n      . ~environment: RescriptRelay.Environment.t,\n      ~pathParams: Js.Dict.t<string>,\n      ~queryParams: RelayRouter__Bindings.QueryParams.t,\n      ~location: RelayRouter__Bindings.History.location,\n    ) => {\n      let apply = (module(RouteRenderer: T__" + routeName + ")) => {\n        let preparedProps = Route__" + routeName + "_route.makePrepareProps(.\n          ~environment,\n          ~pathParams,\n          ~queryParams,\n          ~location,\n        )\n      \n        switch RouteRenderer.renderer.prepareCode {\n          | Some(prepareCode) => prepareCode(. preparedProps)\n          | None => []\n        }\n      }\n\n      switch loadedRouteRenderers.renderer_" + routeName + " {\n      | NotInitiated => loadRouteRenderer()->Js.Promise.then_(() => {\n        switch loadedRouteRenderers.renderer_" + routeName + " {\n          | Loaded(module(RouteRenderer)) => module(RouteRenderer)->apply->Js.Promise.resolve\n          | _ => raise(Route_loading_failed(\"Invalid state after loading route renderer. Please report this error.\"))\n        }\n      }, _)\n      | Pending(promise) => promise->Js.Promise.then_((module(RouteRenderer: T__" + routeName + ")) => {\n          module(RouteRenderer)->apply->Js.Promise.resolve\n        }, _)\n      | Loaded(module(RouteRenderer)) => \n        Js.Promise.make((~resolve, ~reject as _) => {\n          resolve(. apply(module(RouteRenderer)))\n        })\n      }\n    },\n    prepare: (\n      . ~environment: RescriptRelay.Environment.t,\n      ~pathParams: Js.Dict.t<string>,\n      ~queryParams: RelayRouter__Bindings.QueryParams.t,\n      ~location: RelayRouter__Bindings.History.location,\n    ) => {\n      let preparedProps = Route__" + routeName + "_route.makePrepareProps(.\n        ~environment,\n        ~pathParams,\n        ~queryParams,\n        ~location,\n      )\n      let routeKey = Route__" + routeName + "_route.makeRouteKey(~pathParams, ~queryParams)\n\n      switch getPrepared(~routeKey) {\n        | Some({render}) => render\n        | None => \n\n        let preparedRef = ref(NotInitiated)\n\n        let doPrepare = (module(RouteRenderer: T__" + routeName + ")) => {\n          switch RouteRenderer.renderer.prepareCode {\n          | Some(prepareCode) =>\n            let _ = prepareCode(. preparedProps)\n          | None => ()\n          }\n\n          let prepared = RouteRenderer.renderer.prepare(preparedProps)\n          preparedRef.contents = Loaded(prepared)\n\n          prepared\n        }\n        \n        switch loadedRouteRenderers.renderer_" + routeName + " {\n        | NotInitiated =>\n          let preparePromise = loadRouteRenderer()->Js.Promise.then_(() => {\n            switch loadedRouteRenderers.renderer_" + routeName + " {\n            | Loaded(module(RouteRenderer)) => doPrepare(module(RouteRenderer))->Js.Promise.resolve\n            | _ => raise(Route_loading_failed(\"Route renderer not in loaded state even though it should be. This should be impossible, please report this error.\"))\n            }\n          }, _)\n          preparedRef.contents = Pending(preparePromise)\n        | Pending(promise) =>\n          let preparePromise = promise->Js.Promise.then_((module(RouteRenderer: T__" + routeName + ")) => {\n            doPrepare(module(RouteRenderer))->Js.Promise.resolve\n          }, _)\n          preparedRef.contents = Pending(preparePromise)\n        | Loaded(module(RouteRenderer)) => let _ = doPrepare(module(RouteRenderer))\n        }\n\n        let render = (. ~childRoutes) => {\n          React.useEffect0(() => {\n            clearTimeout(~routeKey)\n\n            Some(() => {\n              expirePrepared(~routeKey)\n            })\n          })\n\n          switch (\n            loadedRouteRenderers.renderer_" + routeName + ",\n            preparedRef.contents,\n          ) {\n          | (_, NotInitiated) =>\n            Js.log(\n              \"Warning: Tried to render route with prepared not initiated. This should not happen, prepare should be called prior to any rendering.\",\n            )\n            React.null\n          | (_, Pending(promise)) =>\n            suspend(promise)\n            React.null\n          | (Loaded(module(RouteRenderer: T__" + routeName + ")), Loaded(prepared)) =>\n            RouteRenderer.renderer.render({\n              environment: environment,\n              childRoutes: childRoutes,\n              location: location,\n              prepared: prepared,\n" + prepareParamsQueryParamsStr + "\n            })\n          | _ =>\n            Js.log(\"Warning: Invalid state\")\n            React.null\n          }\n        }\n\n        addPrepared(~routeKey, ~render, ~dispose=(. ) => {\n          switch preparedRef.contents {\n            | Loaded(prepared) => \n              RelayRouter__Internal.extractDisposables(. prepared)\n              ->Belt.Array.forEach(dispose => {\n                dispose(.)\n              })\n            | _ => ()\n          }\n        })\n\n        render\n      }\n    },\n    children: [" + Belt_Array.map(route.children, (function (r) {
            return getRouteDefinition(r, indentation + 1 | 0);
          })).join(",\n") + "],\n  }\n}";
  return str.split("\n").map(function (line) {
                return addIndentation(line, indentation);
              }).join("\n");
}

function getIsRouteActiveFn(route) {
  return "@inline\nlet routePattern = \"" + RescriptRelayRouterCli__Types.RoutePath.toPattern(route.path) + "\"\n\n@live\nlet isRouteActive = ({pathname}: RelayRouter__Bindings.History.location, ~exact: bool=false, ()): bool => {\n  RelayRouter__Internal.matchPathWithOptions({\"path\": routePattern, \"end\": exact}, pathname)->Belt.Option.isSome\n}\n\n@live\nlet useIsRouteActive = (~exact=false, ()) => {\n  let location = RelayRouterUtils.useLocation()\n  React.useMemo1(() => isRouteActive(location, ~exact, ()), [location])\n}";
}

function routeNameAsPolyvariant(route) {
  return "#" + RescriptRelayRouterCli__Types.RouteName.getRouteName(route.name);
}

function getActiveSubRouteFn(route) {
  var elgibleChildren = Belt_Array.keep(route.children, (function (route) {
          return !RescriptRelayRouterCli__Types.RoutePath.getPathSegment(route.path).includes("/");
        }));
  if (elgibleChildren.length === 0) {
    return "";
  }
  var subRouteType = "[" + Belt_Array.map(elgibleChildren, routeNameAsPolyvariant).join(" | ") + "]";
  return "\n@live\ntype subRoute = " + subRouteType + "\n\n@live\nlet useActiveSubRoute = (): option<" + subRouteType + "> => {\n  let location = RelayRouterUtils.useLocation()\n  React.useMemo1(() => {\n    let {pathname} = location\n    " + Belt_Array.mapWithIndex(elgibleChildren, (function (index, child) {
                  var checkStr = "RelayRouter__Internal.matchPath(\"" + RescriptRelayRouterCli__Types.RoutePath.toPattern(child.path) + "\", pathname)->Belt.Option.isSome";
                  var str = {
                    contents: ""
                  };
                  if (index === 0) {
                    RescriptRelayRouterCli__Utils.add(str, "if ");
                  } else {
                    RescriptRelayRouterCli__Utils.add(str, "else if ");
                  }
                  RescriptRelayRouterCli__Utils.add(str, checkStr + " {\n");
                  RescriptRelayRouterCli__Utils.add(str, "      Some(" + routeNameAsPolyvariant(child) + ")\n");
                  RescriptRelayRouterCli__Utils.add(str, "    } ");
                  return str.contents;
                })).join("") + "else {\n      None\n    }\n  }, [location])\n}";
}

function getActiveRouteAssets(route) {
  var str = {
    contents: ""
  };
  RescriptRelayRouterCli__Utils.add(str, getIsRouteActiveFn(route));
  RescriptRelayRouterCli__Utils.add(str, getActiveSubRouteFn(route));
  return str.contents;
}

var Utils;

export {
  Utils ,
  wrapInOpt ,
  SafeParam ,
  getRouteMaker ,
  getRouteMakerIfElgible ,
  getQueryParamAssets ,
  getPrepareAssets ,
  addIndentation ,
  getRouteDefinition ,
  getIsRouteActiveFn ,
  routeNameAsPolyvariant ,
  getActiveSubRouteFn ,
  getActiveRouteAssets ,
  
}
/* RescriptRelayRouterCli__Utils Not a pure module */
