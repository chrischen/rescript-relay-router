// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Path from "path";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as Caml_obj from "rescript/lib/es6/caml_obj.js";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as FastFuzzy from "fast-fuzzy";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as LspProtocol from "./LspProtocol.mjs";
import * as RescriptRelayRouterCli__Types from "../RescriptRelayRouterCli__Types.mjs";
import * as RescriptRelayRouterCli__Utils from "../RescriptRelayRouterCli__Utils.mjs";

function mapRange(range) {
  return {
          start: {
            line: range.start.line,
            character: range.start.column
          },
          end: {
            line: range.end_.line,
            character: range.end_.column
          }
        };
}

function mapPos(loc) {
  return {
          line: loc.line,
          character: loc.column
        };
}

function mapRangeFromStartOnly(range) {
  return {
          start: {
            line: range.start.line,
            character: range.start.column
          },
          end: {
            line: range.start.line,
            character: range.start.column
          }
        };
}

function toRouteFileName(fileUri) {
  return Path.basename(fileUri);
}

function hasPos(range, pos) {
  var pos_0 = pos.line;
  var pos_1 = pos.character;
  var pos$1 = [
    pos_0,
    pos_1
  ];
  var posStart_0 = range.start.line;
  var posStart_1 = range.start.character;
  var posStart = [
    posStart_0,
    posStart_1
  ];
  var posEnd_0 = range.end.line;
  var posEnd_1 = range.end.character;
  var posEnd = [
    posEnd_0,
    posEnd_1
  ];
  if (Caml_obj.caml_lessequal(posStart, pos$1)) {
    return Caml_obj.caml_lessequal(pos$1, posEnd);
  } else {
    return false;
  }
}

function findPosInRouteChildren(children, ctx) {
  var pos = ctx.pos;
  var children$1 = children.slice();
  var $$break = {
    contents: false
  };
  var foundContext = {
    contents: undefined
  };
  var setFoundContext = function (ctx) {
    foundContext.contents = ctx;
    $$break.contents = true;
    
  };
  while($$break.contents === false) {
    var match = children$1.shift();
    if (match !== undefined) {
      if (match.TAG === /* Include */0) {
        var includeEntry = match._0;
        var fileName = includeEntry.fileName;
        var keyLoc = includeEntry.keyLoc;
        if (hasPos(mapRange(includeEntry.loc), pos)) {
          var match$1 = hasPos(mapRange(fileName.loc), pos);
          var match$2 = hasPos(mapRange(keyLoc), pos);
          if (match$1) {
            setFoundContext({
                  TAG: /* IncludeEntry */0,
                  includeEntry: includeEntry,
                  innerLocation: {
                    TAG: /* FileName */0,
                    _0: fileName
                  }
                });
          } else if (match$2) {
            setFoundContext({
                  TAG: /* IncludeEntry */0,
                  includeEntry: includeEntry,
                  innerLocation: {
                    TAG: /* Key */1,
                    _0: keyLoc
                  }
                });
          } else {
            var astLocation = findPosInRouteChildren(includeEntry.content, ctx);
            if (astLocation !== undefined) {
              setFoundContext(astLocation);
            } else {
              setFoundContext({
                    TAG: /* IncludeEntry */0,
                    includeEntry: includeEntry,
                    innerLocation: undefined
                  });
            }
          }
        }
        
      } else {
        var routeEntry = match._0;
        var path = routeEntry.path;
        var name = routeEntry.name;
        if (hasPos(mapRange(routeEntry.loc), pos)) {
          var match$3 = hasPos(mapRange(RescriptRelayRouterCli__Types.RouteName.getLoc(name)), pos);
          var match$4 = hasPos(mapRange(path.loc), pos);
          if (match$3) {
            setFoundContext({
                  TAG: /* RouteEntry */1,
                  routeEntry: routeEntry,
                  innerLocation: {
                    TAG: /* Name */2,
                    _0: {
                      TAG: /* NameText */1,
                      _0: {
                        loc: RescriptRelayRouterCli__Types.RouteName.getLoc(name),
                        text: RescriptRelayRouterCli__Types.RouteName.getRouteName(name)
                      }
                    }
                  }
                });
          } else if (match$4) {
            setFoundContext({
                  TAG: /* RouteEntry */1,
                  routeEntry: routeEntry,
                  innerLocation: {
                    TAG: /* Path */1,
                    _0: {
                      TAG: /* FullPath */1,
                      path: path
                    }
                  }
                });
          } else {
            var astLocation$1 = findPosInRouteChildren(Belt_Option.getWithDefault(routeEntry.children, []), ctx);
            if (astLocation$1 !== undefined) {
              setFoundContext(astLocation$1);
            } else {
              setFoundContext({
                    TAG: /* RouteEntry */1,
                    routeEntry: routeEntry,
                    innerLocation: undefined
                  });
            }
          }
        }
        
      }
    } else {
      $$break.contents = true;
    }
  };
  return foundContext.contents;
}

function findPosContext(routeStructure, ctx) {
  return findPosInRouteChildren(routeStructure.result, ctx);
}

var AstIterator = {
  hasPos: hasPos,
  findPosInRouteChildren: findPosInRouteChildren,
  findPosContext: findPosContext
};

function findRequestContext(routeStructure, ctx) {
  var routeFileName = Path.basename(ctx.fileUri);
  var match = Js_dict.get(routeStructure.routeFiles, routeFileName);
  if (match !== undefined) {
    return findPosInRouteChildren(match.content, ctx);
  }
  
}

function hover(routeStructure, ctx) {
  var astLocation = findRequestContext(routeStructure, ctx);
  if (astLocation === undefined) {
    return ;
  }
  if (astLocation.TAG === /* IncludeEntry */0) {
    var innerLocation = astLocation.innerLocation;
    if (innerLocation === undefined) {
      return ;
    }
    if (innerLocation.TAG !== /* FileName */0) {
      return LspProtocol.makeHover("Defines an include attribute.", mapRange(innerLocation._0));
    }
    var fileName = innerLocation._0;
    return LspProtocol.makeHover("Filename: \"" + fileName.text + "\"", mapRange(fileName.loc));
  }
  var routeEntry = astLocation.routeEntry;
  var routeName = RescriptRelayRouterCli__Types.RouteName.getFullRouteName(routeEntry.name);
  return LspProtocol.makeHover("\n**Full route name**\n\n`" + routeName + "`\n\n\n\n**Full route path**\n\n`" + RescriptRelayRouterCli__Types.RoutePath.getFullRoutePath(routeEntry.routePath) + "`\n", mapRange(routeEntry.loc));
}

function resolveRouteFileCompletions(matchText, includeEntry, ctx) {
  var currentFileName = Path.basename(ctx.fileUri);
  var potentialMatches = Belt_Array.keep(ctx.routeFileNames, (function (routeFileName) {
          if (routeFileName !== currentFileName) {
            return !includeEntry.parentRouteFiles.includes(routeFileName);
          } else {
            return false;
          }
        }));
  if (matchText === "") {
    return Belt_Array.map(potentialMatches, (function (matchedLabel) {
                  return LspProtocol.makeCompletionItem(matchedLabel, /* Class */6);
                }));
  } else {
    return Belt_Array.map(FastFuzzy.search(matchText, potentialMatches), (function (matchedLabel) {
                  return LspProtocol.makeCompletionItem(matchedLabel, /* Class */6);
                }));
  }
}

function completion(routeStructure, ctx) {
  var astLocation = findRequestContext(routeStructure, ctx);
  if (astLocation === undefined) {
    return ;
  }
  var emptyCompletionList = [];
  if (astLocation.TAG === /* IncludeEntry */0) {
    var innerLocation = astLocation.innerLocation;
    if (innerLocation !== undefined) {
      if (innerLocation.TAG === /* FileName */0) {
        return resolveRouteFileCompletions(innerLocation._0.text, astLocation.includeEntry, ctx);
      } else {
        return emptyCompletionList;
      }
    } else {
      return ;
    }
  }
  var innerLocation$1 = astLocation.innerLocation;
  if (innerLocation$1 === undefined) {
    return ;
  }
  switch (innerLocation$1.TAG | 0) {
    case /* Key */0 :
    case /* Path */1 :
        return emptyCompletionList;
    case /* Name */2 :
        return ;
    
  }
}

function codeLens(routeStructure, ctx) {
  var lenses = [];
  var addLens = function (range, command, param) {
    lenses.push(LspProtocol.makeCodeLensItem(range, command));
    
  };
  var traverseRouteChildren = function (routeChildren, ctx) {
    return Belt_Array.forEach(routeChildren, (function (child) {
                  if (child.TAG === /* Include */0) {
                    return ;
                  }
                  var routeEntry = child._0;
                  var fullRouteName = RescriptRelayRouterCli__Types.RouteName.getFullRouteName(routeEntry.name);
                  addLens(mapRangeFromStartOnly(RescriptRelayRouterCli__Types.RouteName.getLoc(routeEntry.name)), LspProtocol.Command.makeTextOnlyCommand(fullRouteName), undefined);
                  addLens(mapRangeFromStartOnly(routeEntry.path.loc), LspProtocol.Command.makeTextOnlyCommand(RescriptRelayRouterCli__Types.RoutePath.getFullRoutePath(routeEntry.routePath)), undefined);
                  return traverseRouteChildren(Belt_Option.getWithDefault(routeEntry.children, []), ctx);
                }));
  };
  var routeFileName = Path.basename(ctx.fileUri);
  var match = Js_dict.get(routeStructure.routeFiles, routeFileName);
  if (match !== undefined) {
    traverseRouteChildren(match.content, ctx);
  }
  var match$1 = lenses.length;
  if (match$1 !== 0) {
    return lenses;
  }
  
}

function routeRendererCodeLens(routeStructure, routeRendererFileName, routeRendererFileContent, ctx) {
  var lines = routeRendererFileContent.split("\n");
  var foundRenderer;
  for(var lineIdx = 0 ,lineIdx_finish = lines.length; lineIdx < lineIdx_finish; ++lineIdx){
    var match = foundRenderer;
    if (match === undefined) {
      var line = lines[lineIdx];
      if (line.includes("makeRenderer(")) {
        var characterStart = line.indexOf("makeRenderer(");
        var characterEnd = line.length;
        var range_start = {
          line: lineIdx,
          character: characterStart
        };
        var range_end = {
          line: lineIdx,
          character: characterEnd
        };
        var range = {
          start: range_start,
          end: range_end
        };
        var routeName = Belt_Option.getWithDefault(Belt_Array.get(routeRendererFileName.split("_route_renderer.res"), 0), "");
        var matchingRouteEntry = {
          contents: undefined
        };
        var findRouteWithName = (function(routeName,matchingRouteEntry){
        return function findRouteWithName(name, routeChildren) {
          return Belt_Array.forEach(routeChildren, (function (routeEntry) {
                        if (routeEntry.TAG === /* Include */0) {
                          return findRouteWithName(name, routeEntry._0.content);
                        }
                        var routeEntry$1 = routeEntry._0;
                        var children = routeEntry$1.children;
                        if (RescriptRelayRouterCli__Types.RouteName.getFullRouteName(routeEntry$1.name) === routeName) {
                          matchingRouteEntry.contents = routeEntry$1;
                          return ;
                        } else if (children !== undefined) {
                          return findRouteWithName(name, children);
                        } else {
                          return ;
                        }
                      }));
        }
        }(routeName,matchingRouteEntry));
        findRouteWithName(routeName, routeStructure.result);
        var routeEntry = matchingRouteEntry.contents;
        if (routeEntry !== undefined) {
          foundRenderer = LspProtocol.makeCodeLensItem(range, LspProtocol.Command.makeOpenFileAtPosCommand("Open route definition", RescriptRelayRouterCli__Utils.pathInRoutesFolder(ctx.config, routeEntry.sourceFile, undefined), mapPos(routeEntry.loc.start)));
        }
        
      }
      
    }
    
  }
  var rendererCodeLens = foundRenderer;
  if (rendererCodeLens !== undefined) {
    return [rendererCodeLens];
  }
  
}

function documentLinks(routeStructure, ctx) {
  var documentLinks$1 = [];
  var addDocumentLink = function (range, fileUri, tooltip, param) {
    documentLinks$1.push(LspProtocol.makeDocumentLink(range, fileUri, tooltip, undefined));
    
  };
  var traverseRouteChildren = function (routeChildren, ctx) {
    return Belt_Array.forEach(routeChildren, (function (child) {
                  if (child.TAG === /* Include */0) {
                    var includeEntry = child._0;
                    if (ctx.routeFileNames.includes(includeEntry.fileName.text)) {
                      return addDocumentLink(mapRange(includeEntry.fileName.loc), RescriptRelayRouterCli__Utils.pathInRoutesFolder(ctx.config, includeEntry.fileName.text, undefined), "Open file", undefined);
                    } else {
                      return ;
                    }
                  }
                  var routeEntry = child._0;
                  addDocumentLink(mapRange(RescriptRelayRouterCli__Types.RouteName.getLoc(routeEntry.name)), RescriptRelayRouterCli__Utils.pathInRoutesFolder(ctx.config, RescriptRelayRouterCli__Types.RouteName.getRouteRendererFileName(routeEntry.name), undefined), "Open route renderer", undefined);
                  return traverseRouteChildren(Belt_Option.getWithDefault(routeEntry.children, []), ctx);
                }));
  };
  var routeFileName = Path.basename(ctx.fileUri);
  var match = Js_dict.get(routeStructure.routeFiles, routeFileName);
  if (match !== undefined) {
    traverseRouteChildren(match.content, ctx);
  }
  var match$1 = documentLinks$1.length;
  if (match$1 !== 0) {
    return documentLinks$1;
  }
  
}

function diagnostics(errors) {
  var diagnosticsPerFile = {};
  Belt_Array.forEach(errors, (function (error) {
          var diagnosticsArray = Js_dict.get(diagnosticsPerFile, error.routeFileName);
          var targetDiagnosticsArray;
          if (diagnosticsArray !== undefined) {
            targetDiagnosticsArray = diagnosticsArray;
          } else {
            var diagnosticsArray$1 = [];
            diagnosticsPerFile[error.routeFileName] = diagnosticsArray$1;
            targetDiagnosticsArray = diagnosticsArray$1;
          }
          targetDiagnosticsArray.push(LspProtocol.makeDiagnostic(mapRange(error.loc), error.message));
          
        }));
  return Js_dict.entries(diagnosticsPerFile);
}

var Bindings;

var Utils;

export {
  Bindings ,
  Utils ,
  mapRange ,
  mapPos ,
  mapRangeFromStartOnly ,
  toRouteFileName ,
  AstIterator ,
  findRequestContext ,
  hover ,
  resolveRouteFileCompletions ,
  completion ,
  codeLens ,
  routeRendererCodeLens ,
  documentLinks ,
  diagnostics ,
  
}
/* path Not a pure module */
