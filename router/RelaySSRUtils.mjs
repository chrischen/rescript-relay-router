// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Curry from "rescript/lib/es6/curry.js";
import * as React from "react";
import * as Js_dict from "rescript/lib/es6/js_dict.js";
import * as ReactDom from "react-dom";
import * as Belt_Array from "rescript/lib/es6/belt_Array.js";
import * as Belt_Option from "rescript/lib/es6/belt_Option.js";
import * as Caml_option from "rescript/lib/es6/caml_option.js";
import * as RelayRuntime from "relay-runtime";
import * as RelayRouter__Bindings from "./RelayRouter__Bindings.mjs";

var streamedPreCache = {};

var replaySubjects = {};

function handleIncomingStreamedDataEntry(streamedEntry) {
  var replaySubject = Js_dict.get(replaySubjects, streamedEntry.id);
  if (replaySubject !== undefined) {
    var replaySubject$1 = Caml_option.valFromOption(replaySubject);
    RelayRouter__Bindings.RelayReplaySubject.applyPayload(replaySubject$1, streamedEntry);
    if (streamedEntry.final) {
      replaySubject$1.complete();
      return Js_dict.unsafeDeleteKey(replaySubjects, streamedEntry.id);
    } else {
      return ;
    }
  }
  var data = Js_dict.get(streamedPreCache, streamedEntry.id);
  if (data !== undefined) {
    data.push(streamedEntry);
  } else {
    streamedPreCache[streamedEntry.id] = [streamedEntry];
  }
  
}

var hasPreparedInitialRoutesRef = {
  contents: false
};

function setHasPreparedInitialRoutes(param) {
  hasPreparedInitialRoutesRef.contents = true;
  
}

function bootOnClient(rootElementId, render) {
  var boot = function (param) {
    ReactDom.hydrateRoot(document.getElementById(rootElementId), render);
    
  };
  window.__BOOT = boot;
  if (Belt_Option.getWithDefault(Caml_option.nullable_to_opt(window.__READY_TO_BOOT), false)) {
    boot(undefined);
  }
  Belt_Array.forEach(Belt_Option.getWithDefault(Caml_option.nullable_to_opt(window.__RELAY_DATA), []), handleIncomingStreamedDataEntry);
  window.__RELAY_DATA = {
    push: handleIncomingStreamedDataEntry
  };
  
}

function subscribeToReplaySubject(replaySubject, id, sink) {
  return replaySubject.subscribe({
              next: (function (data) {
                  return sink.next(data);
                }),
              error: (function (e) {
                  sink.error(e);
                  return Js_dict.unsafeDeleteKey(replaySubjects, id);
                }),
              complete: (function (param) {
                  sink.complete();
                  return Js_dict.unsafeDeleteKey(replaySubjects, id);
                })
            });
}

function applyPreCacheData(replaySubject, id) {
  var preCacheData = Js_dict.get(streamedPreCache, id);
  if (preCacheData !== undefined) {
    Belt_Array.forEach(preCacheData, (function (data) {
            replaySubject.next(data.response);
            if (data.final) {
              replaySubject.complete();
              return Js_dict.unsafeDeleteKey(replaySubjects, id);
            }
            
          }));
    return Js_dict.unsafeDeleteKey(streamedPreCache, id);
  }
  
}

function handleClientRequestForId(id, sink) {
  var replaySubject = Js_dict.get(replaySubjects, id);
  if (replaySubject !== undefined) {
    return /* Handled */{
            _0: subscribeToReplaySubject(Caml_option.valFromOption(replaySubject), id, sink)
          };
  }
  var preCacheData = Js_dict.get(streamedPreCache, id);
  if (preCacheData === undefined) {
    return /* NotHandled */0;
  }
  var match = preCacheData.length;
  if (match === 0) {
    return /* NotHandled */0;
  }
  var replaySubject$1 = new RelayRuntime.ReplaySubject();
  var subscription = subscribeToReplaySubject(replaySubject$1, id, sink);
  applyPreCacheData(replaySubject$1, id);
  return /* Handled */{
          _0: subscription
        };
}

function makeIdentifier(operation, variables) {
  return operation.name + JSON.stringify(variables);
}

function makeClientFetchFunction($$fetch, operation, variables, _cacheConfig, _uploads) {
  return RelayRuntime.Observable.create(function (sink) {
              var id = makeIdentifier(operation, variables);
              if (hasPreparedInitialRoutesRef.contents) {
                var subscription = handleClientRequestForId(id, sink);
                if (subscription) {
                  return subscription._0;
                } else {
                  return Curry._5($$fetch, sink, operation, variables, _cacheConfig, _uploads);
                }
              }
              var replaySubject = Js_dict.get(replaySubjects, id);
              var replaySubject$1;
              if (replaySubject !== undefined) {
                replaySubject$1 = Caml_option.valFromOption(replaySubject);
              } else {
                var replaySubject$2 = new RelayRuntime.ReplaySubject();
                replaySubjects[id] = replaySubject$2;
                replaySubject$1 = replaySubject$2;
              }
              var subscription$1 = subscribeToReplaySubject(replaySubject$1, id, sink);
              applyPreCacheData(replaySubject$1, id);
              return subscription$1;
            });
}

function makeServerFetchFunction(onResponseReceived, $$fetch, operation, variables, cacheConfig, uploads) {
  var observable = RelayRuntime.Observable.create(function (sink) {
        return Curry._5($$fetch, sink, operation, variables, cacheConfig, uploads);
      });
  observable.subscribe({
        next: (function (payload) {
            return Curry._3(onResponseReceived, makeIdentifier(operation, variables), payload, true);
          })
      });
  return observable;
}

var context = React.createContext(function (param) {
      
    });

var make = context.Provider;

function makeProps(value, children, param) {
  return {
          value: value,
          children: children
        };
}

var Provider = {
  make: make,
  makeProps: makeProps
};

function use(param) {
  return React.useContext(context);
}

var ssr = import.meta.env.SSR;

var AssetRegisterer = {
  use: use,
  Provider: Provider
};

export {
  bootOnClient ,
  setHasPreparedInitialRoutes ,
  makeClientFetchFunction ,
  makeServerFetchFunction ,
  ssr ,
  AssetRegisterer ,
  
}
/* context Not a pure module */
