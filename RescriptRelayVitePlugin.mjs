import fs from "fs";
import path from "path";
import readline from "readline";
import { runCli } from "./cli/RescriptRelayRouterCli__Commands.mjs";

// Expected to run in vite.config.js folder, right next to bsconfig.
let cwd = process.cwd();

let findGeneratedModule = (moduleName) => {
  return new Promise((resolve, reject) => {
    let s = fs.createReadStream(path.resolve(cwd, "./lib/bs/build.ninja"));

    let rl = readline.createInterface({
      input: s,
      terminal: false,
    });

    let hasReachedModuleInFile = false;
    let found = false;

    rl.on("line", (line) => {
      // Only look at `o` (output) lines as our "when past module" logic may get confused
      // by other things interjected.
      if (!line.startsWith("o")) {
        return;
      }

      let lineIsForModule = line.includes(`/${moduleName}.`);

      // Close as soon as we've walked past all lines concerning this module. The log
      // groups all lines concerning a specific module, so we can safely say that
      // whenever we see a new module after looping through the old one, we don't need
      // to look more.
      if (hasReachedModuleInFile && !lineIsForModule) {
        s.close();
        rl.close();
        // Prevent subsequent `line` events from firing.
        rl.removeAllListeners();
        return;
      }

      if (lineIsForModule && !hasReachedModuleInFile) {
        hasReachedModuleInFile = true;
      }

      if (lineIsForModule) {
        let [relativePathToGeneratedModule] =
          / (\.\.\/.*js) /g.exec(line) ?? [];

        if (relativePathToGeneratedModule) {
          found = true;
          resolve(
            path.resolve(cwd, "./lib/bs", relativePathToGeneratedModule.trim())
          );
        }
      }
    });

    rl.on("close", () => {
      if (!found) {
        reject(new Error(`Module '${moduleName}' not found.`));
      }
    });
  });
};

export let rescriptRelayVitePlugin = ({
  autoScaffoldRenderers = true,
  deleteRemoved = true,
} = {}) => {
  let watcher;
  let outputCount;
  let manifest = {};
  let config;

  return {
    name: "rescript-relay",
    configResolved(resolvedConfig) {
      config = resolvedConfig;
      outputCount = 0;
    },
    buildStart() {
      // Run single generate in prod
      if (process.env.NODE_ENV === "production") {
        runCli(
          [
            "generate",
            autoScaffoldRenderers ? "-scaffold-renderers" : null,
            deleteRemoved ? "-delete-removed" : null,
          ].filter((v) => v != null)
        );
        return;
      }

      try {
        if (watcher != null) {
          watcher.close();
        }

        let res = runCli(
          [
            "generate",
            "-w",
            autoScaffoldRenderers ? "-scaffold-renderers" : null,
            deleteRemoved ? "-delete-removed" : null,
          ].filter((v) => v != null)
        );

        if (
          res != null &&
          typeof res === "object" &&
          res.hasOwnProperty("watcher")
        ) {
          watcher = res.watcher;
        } else {
          console.log("Failed starting watcher.");
        }
      } catch (e) {
        console.error(e);
      }
    },
    buildEnd() {
      if (watcher != null) {
        watcher.close();
      }
    },
    async resolveId(id) {
      if (id != null && id.startsWith("@rescriptModule/")) {
        let moduleName = id.split("@rescriptModule/")[1];
        let loc = await findGeneratedModule(moduleName);

        if (loc != null) {
          return { id: loc };
        }
      }
    },

    // This below takes care of inlining chunk names into the source JS, so we
    // can use those chunk names to preload code via script tags on the
    // client.

    // This first pass is only relevant in dev. It will replace all
    // `__$rescriptChunkName__: "ModuleName" entries with the full file
    // location of "ModuleName", so that we can preload the full module via
    // the file name. This is handled differently in production, where we need
    // to do a full lookup of what bundle the target file is in, which we
    // can't do until all bundles have been rendered.
    async transform(code) {
      if (config.mode === "production") {
        return null;
      }

      if (!code.startsWith("// Generated by ReScript")) {
        return null;
      }

      let didReplace = false;

      let newCode = await replaceAsync(
        code,
        /__\$rescriptChunkName__: "([A-Za-z0-9_]+)"/gm,
        async (_match, moduleName) => {
          if (moduleName != null) {
            let loc = await findGeneratedModule(moduleName);

            if (loc != null) {
              didReplace = true;
              // TODO: Source maps
              return `__$rescriptChunkName__: "${loc}"`;
            }
          }
        }
      );

      if (didReplace) {
        return newCode;
      }

      return null;
    },

    // This second step runs only in prod, and will track all bundle chunks,
    // and map them to whatever ReScript modules they contain. This helps us
    // in two ways:
    //
    // 1) It allows us to emit a specialized manifest we can use during SSR to
    //    push preloading of code assets we'll know we'll need ASAP
    //
    // 2) It lets us use the same information to inline bundle chunk location
    //    strings of ReScript modules in the prod client build, which we then
    //    use to preload code via script tags on the client.
    generateBundle(_, bundle) {
      for (let file in bundle) {
        let chunk = bundle[file];
        if (chunk.type === "chunk" && chunk.facadeModuleId != null) {
          let moduleName = path.basename(chunk.facadeModuleId).split(".")[0];
          if (moduleName != null) {
            manifest[moduleName] = chunk.fileName;
          }
        }
      }

      // This below is mostly copied from the internal Vite manifest plugin.
      outputCount++;
      let output = config.build.rollupOptions?.output;
      let outputLength = Array.isArray(output) ? output.length : 1;
      if (outputCount >= outputLength) {
        if (config.mode === "production" && !Boolean(config.build.ssr)) {
          this.emitFile({
            fileName: "res-manifest.json",
            type: "asset",
            source: JSON.stringify(manifest, null, 2),
          });
        }
      }
    },
    // This final step runs when all bundles have been written. It does the
    // final swap of ReScript module names to a loadable src string pointing
    // to the bundle where that ReScript module is included. This runs as a
    // post-build step, and needs to run as that because we need the full
    // build to finish before we have enough information to do the replace.
    writeBundle(outConfig, bundle) {
      // TODO: We might be able to optimize this (skip reading through all of
      // the generated code) by tracking what ReScript module chunk strings
      // are included in what bundles, and only replacing in those bundles,
      // skipping the rest.
      Object.entries(bundle).forEach(([_bundleName, bundleContents]) => {
        let code = bundleContents.code;

        if (code != null) {
          let didReplace = false;
          // TODO: Source maps
          let newCode = code.replace(
            /__\$rescriptChunkName__:"([A-Za-z0-9_]+)"/gm,
            (match, moduleName) => {
              didReplace = true;

              return `__$rescriptChunkName__:"${
                manifest[moduleName] ?? match
              }"`;
            }
          );

          if (didReplace) {
            fs.writeFileSync(
              path.resolve(outConfig.dir, bundleContents.fileName),
              newCode
            );
          }
        }
      });
    },
  };
};

// Copied from some async replacer lib.
function replaceAsync(string, searchValue, replacer) {
  try {
    if (typeof replacer === "function") {
      // 1. Run fake pass of `replace`, collect values from `replacer` calls
      // 2. Resolve them with `Promise.all`
      // 3. Run `replace` with resolved values
      var values = [];
      String.prototype.replace.call(string, searchValue, function () {
        values.push(replacer.apply(undefined, arguments));
        return "";
      });
      return Promise.all(values).then(function (resolvedValues) {
        return String.prototype.replace.call(string, searchValue, function () {
          return resolvedValues.shift();
        });
      });
    } else {
      return Promise.resolve(
        String.prototype.replace.call(string, searchValue, replacer)
      );
    }
  } catch (error) {
    return Promise.reject(error);
  }
}
